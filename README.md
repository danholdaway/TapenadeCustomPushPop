## Custom interface for the Tapenade inline automatic differentiation software

By default Tapenade recomuptes the reference state trajectory to linearize around, acheived either in a single subroutine or seperately, as a forward and then backward sweep. In iterative models, which linearize around the same reference state repeatedly, such as in data assimilation, this leads to superfluous work being done. In data assimilation speed is of the essence and the recomputation can be too expensive.

The enclosed software demonstrates the use of a custom interface to the Tapenade push/pop routines that can limit recomputation for an iterative model. The tool is demonstrated by using a simple one dimensional advection. The iterations are represented by calling the model multiple times with the same reference state initial conditions. The initial perturbations are also fixed, whereas in reality would change with each iteration; this doens't matter for the purposes of demonstration.

### This custom interface provides the following functionality:
* Hold checkpoints in a static array so that the forward sweep of code can be tuned off after three itations.
* Allows for compile time choice of precision of real variables. Tapenade typically requires this choice to be made before being generated.
* Can check whether a particular push/pop was actually necessary as thus reduce the overall memory footprint. This helps make the code useable in different applications. Such as in operational applications where large number of processors are used, versus research applications where fewer processors are avaialble.
* User can specify the amount of memory avaialble and the tool will revert to the usual Tapenade approach if exceeded.
* We plan to add the ability to profile particular subroutines memory footprint and number of calls to push/pop.

### Getting Started

Compile the Tapenade/adBuffer.f and Tapenade/adStack.c following the instuctions issued by Inria Tapenade.

To compile the advection scheme, edit the compile.csh file with appropriate definition of intel and or gfortran compiler and issue ./compile.csh int or ./compile.csh gcc

Run the code with ./adv_1d.x


### Description of code

The custom interface is contained in tapenade_iter.F90. The only changes required to the adjoint code generated by Tapenade is to replace all calls to push and pop to the interface contained in tapenade_iter.F90. E.g.

call pushrcontrol_1b(branch) -> call pushcontrol(branch,1)  
call pushreal4(rscalar) -> call pushrealarray(rscalar)  
call pushreal8array(rarray,size) -> call pushrealarray(rarray,size)  
call pushinteger4(iscalar) -> call pushintegerarray(iarray)  
call pushinteger4array(iarray,size) -> call pushintegerarray(iarray,size)  

and similarly for pop. This can easily be achieved with sed replace commands for large codes.

The custom interface builds a static array for each 'calling module'. In an atmopsheric model, for example, modules might be the dyn core and each physics routine. 

First some details about the module must be initialzed for to tell tapenade_iter.F90 what to do. First an integer has to be defined that is associated only with this module and each integer has to be less than or equal to the total number of modules.

```
cp_adv_ind = 1 
cp_iter(cp_adv_ind)%my_name(1:3) = 'adv'            !Give myself a name
cp_iter(cp_adv_ind)%cp_test = .false.               !Run in test mode?
cp_iter(cp_adv_ind)%cp_rep = .false.                !Write reports on memory use etc?
```

The below are optional and their default values are shown. check_st tells the code to perform a check on whether a checkpoint was necessary. This will be slower than not doing so but only at one iteration. The other variables are used to debug the code. One runs a single iteration at a time and values to feed in will be output. So dim_st are given with cp_test = .true. on iteration 1. dim_cp are given after iteration 2 is run with the appropriate values in dim_st. Essentially dimensions for checkpoint arrays are learnt from the previous iteration so when debugging these have to be provided.

```
cp_iter(cp_adv_ind)%check_st_control = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_integer = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_real_r4 = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_real_r8 = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%test_dim_st_control = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_integer = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_real_r4 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_real_r8 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_control = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_integer = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_real_r4 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_real_r8 = 0         !Testmode, run one iteration at a time
```


Before the adjoint of that component is called routines are placed around them to switch the active module in tapenade_iter.F90

For example the code inside a particular module might look like:
```
call cp_mod_ini(mod_ind)

if (iter < 4) then
call some_science_fwd(arguments)
endif

call cp_mod_mid(mod_ind)

call some_science_bwd(arguments)

call cp_mod_end(mod_ind)
```
ini, mid and end are routines at the lower level that adjust pointers to the static arrays, reset counters and can print information about checkpointing, if necessary.


--------------

At the highest level of the code and outside the iterative loop some general initialization and finalization are required, called with e.g.
```
cp_iter_controls%cp_i      First iteration, 1=use tool, 0=pass through and use regular Tapenade approach
cp_iter_controls%cp_nt     Number of time steps. Optionally arrange checkpoints by timestep
cp_iter_controls%cp_t      Set to 1
cp_iter_controls%cp_gb     Optional: provide upper limit (per processor) of memory use
cp_iter_controls%cp_nm     Number of modules using a static array (2 in below example)

call initialize_cp_iter

do iter = 1,niter
 cp_iter_controls%cp_i = iter
 !If there was a timestep loop here then cp_iter_controls%cp_nt would be ticked too (not counted down!)
 call module1
 call module2
enddo

call finalize_cp_iter
```



## Custom interface for the Tapenade inline automatic differentiation software

When integrating either tangent linear or adjoint models the reference state is required to linearize around. Tapenade automatic differentiation recomputes the reference state alongside the linearization for the tangent linear model and in a forward sweep and 'push to stack' for the adjoint. As the adjoint is integrated the reference state is recovered from the stack in reverse order using a 'pop'. As the reference state is recovered it is also deallocated.

In some applications, such as 4DVar data assimilation, the tangent linear and adjoint models are called iteratively with a fixed reference state. In both the tangent linear and adjoint models this results in repeat recomputation of the reference state. For the tangent linear model little can be done to reduce this work load given the recomputation is so ingrained in the code. For the adjoint, however, it is possible to group all forward and backward calculations. That way we can intercept the Tapenade push and pop calls and replace them with an alternate form that does not deallocate the stack and ultimately turn off the forward call after a certain number of iterations.

The custom interface, included in this repository, is designed so that it can be used with minimal automatic changes to the code that is genrated using Tapenade.

The enclosed software demonstrates the use of a custom interface to the Tapenade push/pop routines that can limit recomputation for an iterative model. It also demonstrates how the code is developed from the Tapenade software. The tool is demonstrated by using a simple one dimensional advection. The iterations are represented by calling the model multiple times with the same reference state initial conditions. The initial perturbations are also fixed, whereas in reality would change with each iteration; this doens't matter for the purposes of demonstration.

### This custom interface provides the following functionality:
* Hold checkpoints in a static array so that the forward sweep of code can be tuned off after three itations.
* Allows for compile time choice of precision of real variables. Tapenade typically requires this choice to be made before being generated.
* Can check whether a particular push/pop was actually necessary as thus reduce the overall memory footprint. This helps make the code useable in different applications. Such as in operational applications where large number of processors are used, versus research applications where fewer processors are avaialble.
* User can specify the amount of memory avaialble and the tool will revert to the usual Tapenade approach if exceeded.
* We plan to add the ability to profile particular subroutines memory footprint and number of calls to push/pop.

### Getting Started

Compile the Tapenade/adBuffer.f and Tapenade/adStack.c following the instuctions issued by Inria Tapenade.

To compile the advection scheme, edit the compile.csh file with appropriate definition of intel and or gfortran compiler and issue ./compile.csh int or ./compile.csh gcc

Run the code with ./adv_1d.x

### TLM/ADM Development

The directory Tapenade/ shows how the tlm and adm are generated. advection.F90 is copied from the directory above and then the tlm and adm are generated by running run_tap.csh, first edit the file to point to the local Tapenade build. The standard Tapnenade output can be seen in Tapenade/tlm Tapenade/adm and the necessary modifications can be seen by comparing with the files at the top level.

### Modifications to use custom interface

The custom interface is contained in tapenade_iter.F90.  As can be seen from the comparison between the default and used tlm and adm files the only necessary changes to the Tapenade generated code is to replace the call push and call pop calls with calls to the custom checkpointing versions. For example:

```
call pushcontrol_xb(branch) -> call pushcontrol(x,branch)  
call pushreal4(rscalar) -> call pushrealarray(rscalar)  
call pushreal8array(rarray,size) -> call pushrealarray(rarray,size)  
call pushinteger4(iscalar) -> call pushintegerarray(iarray)  
call pushinteger4array(iarray,size) -> call pushintegerarray(iarray,size) 
```
and similarly for call pop. This can easily be achieved with sed replace commands for large codes.
  
  
There are two main structures to initialize when using the custom interface. Firstly there is a model wide structure called cp_iter_controls that contain all the main controls for the custom interface. Each module/subroutine/component can create its own stack and set of checkpointing configurations, which are contained in cp_iter. cp_iter(:) has the dimension of the number of modules that will use the interface. In an atmopsheric model, for example, modules might be the dyn core and each physics routine. 

The model wide configuration is initialized as, for example:

```
use tapenade_iter, only: cp_iter_controls

logical :: use_custom_cp = .true.

cp_iter_controls%cp_i = 0     !Start with set to zero, if not updated wont do anything
cp_iter_controls%cp_nt = 1    !Number of time steps. Optionally arrange checkpoints by timestep
cp_iter_controls%cp_t = 1     !Set to 1
cp_iter_controls%cp_gb = -0.1 !Optional: if >0 provide upper limit (per processor) of memory use
cp_iter_controls%cp_nm = 2    !Number of modules using a static array (2 in below example)

!Allocate cp_iter and do various initialize things
call initialize_cp_iter

!The main iteration loop
do iter = 1,niter
 if (use_custom_cp) cp_iter_controls%cp_i = iter
 !If there was a timestep loop here then cp_iter_controls%cp_nt would be ticked too (not counted down!)
 call module1
 call module2
enddo

!Deallocate any memory used by custom checkpointing
call finalize_cp_iter
```

Within a module that uses the custom checkpointing first some details about the module must be initialzed to tell tapenade_iter.F90 what to do. First an integer has to be defined that is associated only with this module. Each module identifying integer has to be <= to the total number of modules.

```
cp_adv_ind = 1 
cp_iter(cp_adv_ind)%my_name(1:3) = 'adv'            !Give myself a name
cp_iter(cp_adv_ind)%cp_test = .false.               !Run in test mode?
cp_iter(cp_adv_ind)%cp_rep = .false.                !Write reports on memory use etc?
```

The below are optional and their default values are shown. check_st tells the code to perform a check on whether a checkpoint was necessary. This will be slower than not doing so but only at one iteration. The other variables are used to debug the code. One runs a single iteration at a time and values to feed in will be output. So dim_st are given with cp_test = .true. on iteration 1. dim_cp are given after iteration 2 is run with the appropriate values in dim_st. Essentially dimensions for checkpoint arrays are learnt from the previous iteration so when debugging these have to be provided.

```
cp_iter(cp_adv_ind)%check_st_control = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_integer = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_real_r4 = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%check_st_real_r8 = .false.      !Check whether checkpoints are necessary?
cp_iter(cp_adv_ind)%test_dim_st_control = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_integer = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_real_r4 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_st_real_r8 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_control = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_integer = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_real_r4 = 0         !Testmode, run one iteration at a time
cp_iter(cp_adv_ind)%test_dim_cp_real_r8 = 0         !Testmode, run one iteration at a time
```

Where the actual adjoint routines are called some single line calls need to be inserted to switch pointers so that the correct stack is being worked with. For example the code inside a particular module might look like:

```
call cp_mod_ini(mod_ind)

if (iter < 4) then
call some_science_fwd(arguments)
endif

call cp_mod_mid(mod_ind)

call some_science_bwd(arguments)

call cp_mod_end(mod_ind)
```

cp_mod_ini, cp_mod_mid and cp_mod_end are routines at the lower level that adjust pointers to the static arrays, reset counters and can print information about checkpointing, if necessary.






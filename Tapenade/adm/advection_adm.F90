!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
MODULE ADVECTION_MOD_DIFF
  IMPLICIT NONE
  PRIVATE 
  PUBLIC advect_1d, gridind_type
  PUBLIC advect_1d_fwd, advect_1d_bwd
  TYPE GRIDIND_TYPE
      REAL*8, ALLOCATABLE :: x(:)
      INTEGER, ALLOCATABLE :: fx(:)
      INTEGER, ALLOCATABLE :: f1x(:)
      INTEGER, ALLOCATABLE :: g1x(:)
  END TYPE GRIDIND_TYPE

CONTAINS
!  Differentiation of advect_1d in reverse (adjoint) mode, forward sweep (with options split(advection_mod.advect_1d)):
!   gradient     of useful results: u y
!   with respect to varying inputs: u x y
  SUBROUTINE ADVECT_1D_FWD(nx, nt, x, y, c, dt, dx, u, grid)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, nt
    REAL*8, INTENT(IN) :: c, dt, dx, u
    REAL*8, INTENT(INOUT) :: x(nx)
    REAL*8 :: y(nx)
    TYPE(GRIDIND_TYPE), INTENT(IN) :: grid
    INTEGER :: t, j
    REAL*8 :: xold(nx), xhalf(nx)
    xold = x
!Advect once around the domain
    DO t=1,nt
      DO j=1,nx
        CALL PUSHREAL8(xhalf(grid%fx(j)))
        xhalf(grid%fx(j)) = 0.5*(xold(grid%fx(j))+xold(grid%g1x(j))) - &
&         0.5*c*(xold(grid%fx(j))-xold(grid%g1x(j)))
      END DO
      DO j=1,nx
        xold(grid%fx(j)) = xold(grid%fx(j)) - u*dt/dx*(xhalf(grid%f1x(j)&
&         )-xhalf(grid%fx(j)))
      END DO
    END DO
    CALL PUSHREAL8ARRAY(xhalf, nx)
  END SUBROUTINE ADVECT_1D_FWD
!  Differentiation of advect_1d in reverse (adjoint) mode, backward sweep (with options split(advection_mod.advect_1d)):
!   gradient     of useful results: u y
!   with respect to varying inputs: u x y
!   RW status of diff variables: u:incr x:out y:in-zero
  SUBROUTINE ADVECT_1D_BWD(nx, nt, x, x_ad, y, y_ad, c, dt, dx, u, u_ad&
&   , grid)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, nt
    REAL*8, INTENT(IN) :: c, dt, dx, u
    REAL*8 :: u_ad
    REAL*8, INTENT(INOUT) :: x(nx)
    REAL*8, INTENT(INOUT) :: x_ad(nx)
    REAL*8 :: y(nx)
    REAL*8 :: y_ad(nx)
    TYPE(GRIDIND_TYPE), INTENT(IN) :: grid
    INTEGER :: t, j
    REAL*8 :: xold(nx), xhalf(nx)
    REAL*8 :: xold_ad(nx), xhalf_ad(nx)
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    CALL POPREAL8ARRAY(xhalf, nx)
    xold_ad = 0.0_8
    xold_ad = y_ad
    xhalf_ad = 0.0_8
    DO t=nt,1,-1
      DO j=nx,1,-1
        temp_ad0 = -(dt*u*xold_ad(grid%fx(j))/dx)
        xhalf_ad(grid%f1x(j)) = xhalf_ad(grid%f1x(j)) + temp_ad0
        xhalf_ad(grid%fx(j)) = xhalf_ad(grid%fx(j)) - temp_ad0
        u_ad = u_ad - (xhalf(grid%f1x(j))-xhalf(grid%fx(j)))*dt*xold_ad(&
&         grid%fx(j))/dx
      END DO
      DO j=nx,1,-1
        CALL POPREAL8(xhalf(grid%fx(j)))
        temp_ad = -(c*0.5*xhalf_ad(grid%fx(j)))
        xold_ad(grid%fx(j)) = xold_ad(grid%fx(j)) + temp_ad + 0.5*&
&         xhalf_ad(grid%fx(j))
        xold_ad(grid%g1x(j)) = xold_ad(grid%g1x(j)) + 0.5*xhalf_ad(grid%&
&         fx(j)) - temp_ad
        xhalf_ad(grid%fx(j)) = 0.0_8
      END DO
    END DO
    x_ad = 0.0_8
    x_ad = xold_ad
    y_ad = 0.0_8
  END SUBROUTINE ADVECT_1D_BWD
  SUBROUTINE ADVECT_1D(nx, nt, x, y, c, dt, dx, u, grid)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: nx, nt
    REAL*8, INTENT(IN) :: c, dt, dx, u
    REAL*8, INTENT(INOUT) :: x(nx)
    REAL*8, INTENT(OUT) :: y(nx)
    TYPE(GRIDIND_TYPE), INTENT(IN) :: grid
    INTEGER :: t, j
    REAL*8 :: xold(nx), xhalf(nx)
    xold = x
    x = 0.0
!Advect once around the domain
    DO t=1,nt
      DO j=1,nx
        xhalf(grid%fx(j)) = 0.5*(xold(grid%fx(j))+xold(grid%g1x(j))) - &
&         0.5*c*(xold(grid%fx(j))-xold(grid%g1x(j)))
      END DO
      DO j=1,nx
        xold(grid%fx(j)) = xold(grid%fx(j)) - u*dt/dx*(xhalf(grid%f1x(j)&
&         )-xhalf(grid%fx(j)))
      END DO
    END DO
    y = xold
  END SUBROUTINE ADVECT_1D
END MODULE ADVECTION_MOD_DIFF
